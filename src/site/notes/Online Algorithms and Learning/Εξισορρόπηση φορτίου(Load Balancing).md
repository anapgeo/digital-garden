---
{"dg-publish":true,"permalink":"/online-algorithms-and-learning/eksisorropisi-fortioy-load-balancing/","created":"2025-03-25T14:58:23.060+02:00","updated":"2025-03-28T12:28:34.044+02:00"}
---

## To πρόβλημα

- Διαθέτουμε m πανομοιότυπες μηχανές 
- Θέλουμε να εξυπηρετήσουμε n εργασίες οι οποίες έρχονται σειριακά 1,2,..,n
- Κάθε εργασία $j$ πρέπει να εκτελεστεί συνεχόμενα σε μια μηχανή και χρειάζεται χρόνο $t_j$ για να ολοκληρωθεί
- Κάθε μηχανή μπορεί να διεκπεραιώνει μόνο μια εργασία κάθε χρονική στιγμή
- Ο αλγόριθμος δεν γνωρίζει τίποτα για τις εργασίες που ακολουθούν αυτής που του έρχεται πως εξυπηρέτηση κάθε χρονική στιγμή, αλλά θα πρέπει να λάβει την απόφαση σε ποια μηχανή θα δώσει την εργασία που λαμβάνει

Κλασσικό παράδειγμα προβλήματος Load Balancing είναι όταν έχουμε κάποιους πανομοιότυπους servers οι οποίοι δέχονται με online τρόπο μια σειρά από αιτήματα να κάνουν κάποιες εργασίες. Πως θα πρέπει να κατανείμουμε τις εργασίες σε αυτούς τους servers ώστε να έχουμε τη μικρότερη δυνατή καθυστέρηση;

Ορίζουμε:

- $S[i]$: το υποσύνολο των εργασιών που ανατίθενται στη μηχανή $i$
- $L[i]=\sum_{j \in S[i]}t_j$ : το φορτίο της μηχανής $i$ (με άλλα λόγια πόσο χρόνο χρειάζεται η μηχανή $i$ να φέρει σε πέρας τις εργασίες οι οποίες της έχουν ανατεθεί)
- $L=\max_i L[i]$ : διάρκεια εκτέλεση ή αλλιώς makespan, είναι το μέγιστο φορτίο μεταξύ όλων των μηχανών (δηλαδή ο χρόνος που απαιτείτε για να τελειώσουν όλες οι μηχανές)

Πρακτικά ο στόχος μας είναι να έχουμε όσο το δυνατό μικρότερο makespan, για να το επιτυχουμε αυτό ουσιαστικά θα πρέπει να επιτύχουμε μια εξισορρόπηση των φορτίων στις μηχανές. Για αυτό και το πρόβλημα ονομάζεται Load Balancing.

![Screenshot_12.png|300](/img/user/Online%20Algorithms%20and%20Learning/Screenshot_12.png)


Γενικά ακόμα και στην μη online περίπτωση όπου γνωρίζουμε τα πάντα για τις εργασίες που πρέπει να εκτελέσουμε και έχουμε μόνο 2 διαθέσιμες μηχανές, το πρόβλημα εύρεσης της βέλτιστης λύσης είναι NP-hard.

## Ένας άπληστος αλγόριθμος

### Υλοποίηση 

Θα αναλύσουμε ένα απλό άπληστο αλγόριθμο για την επίλυση του προβλήματος που αναλύσαμε πρηγουμένως. Ο αλγόριθμος αυτός ονομάζεται List-scheduling. Η ιδέα πίσω από αυτόν τον αλγόριθμο είναι ιδιαίτερα απλή: Κάθε φορά που λαμβάνεις μια νέα εργασία $j$ ανέθεσε τη στη μηχανή $i$ η οποία έχει το μικρότερο φόρτο εργασίας τη δεδομένη χρονική στιγμή


![Screenshot_13.png](/img/user/Online%20Algorithms%20and%20Learning/Screenshot_13.png)

Πολυπλοκότητα: $Ο(nlogm)$ με τη χρήση ουράς προτεραιότητας για τα φορτία $L[k]$ (αυτό μας εξασφαλίζει πως μπορούμε να ανακτήσουμε τη μηχανή με το μικρότερο φορτίο σε μια εντολή χωρίς καθυστέρηση)

### Ανάλυση

Πόσο καλά τα πάει ο αλγόριθμος μας σε σχέση με τη βέλτιστη λύση; Έχει αποδειχτεί από το Graham το 1966 πως ο λόγος προσέγγισης του αλγορίθμου αυτού είναι το πολύ 2. Δηλαδή δεν μπορούμε να καθυστερήσουμε περισσότερο από το διπλάσιο της βέλτιστης καθυστέρησης.

Για να αποδείξουμε το παραπάνω αρχικά θα χρησιμοποιήσουμε τα παρακάτω λήμματα:

Λήμμα 1:
> Για όλα τα k: το βέλτιστο makespan $L^* \geq t_k$ -> Με απλά λόγια ο χρόνος εκτέλεσης όλων των εργασιών δεν μπορεί να είναι μικρότερος από το χρόνο εκτέλεσης της πιο χρονοβόρας εργασίας

Λήμμα 2:
> Το βέλτιστο makespan $L^* \geq \frac{1}{m}\sum_k t_k$ -> Ο συνολικός χρόνος εκτέλεσεις θα πρέπει να είναι τουλάχιστον $1/m$ κλάσμα του συνολικού χρόνου που απαιτουν όλες οι εργασίες αν εκτελούνταν σειριακά. Μπορείς να το σκεφτείς ως εξης: Έστω πως στην αρχή είχες μόνο μια μηχανή, τότε ο συνολικός χρόνος θα ήταν $\sum_k t_k$. Αν τώρα μας δώσουν m ίδιες με την αρχική μηχανές, αν οι εργασίες αυτές είναι ίδιες, άρα όλα τα $t_k$ είναι ίδια, τότε ο απαιτούμενος χρόνος θα είναι $\frac{1}{m}\sum_k t_k$. Στην περίπτωση των ανόμοιων εργασιών όπως και να τις χωρίσουμε είναι αδύνατο κάποια μηχανή να μην περνάει το όριο του $\frac{1}{m}\sum_k t_k$. 


Απόδειξη:

Έστω ότι μας έρχεται η τελευταία εργασία $j$. Σύμφωνα με τον List_scheduling αλγόριθμο θα κατανείμουμε την εργασία αυτή στη μηχανή $i$ με το μικρότερο φορτίο. Άρα το φορτίο της μηχανής $i$ πριν από την άφιξη της εργασία $j$  είναι $L[i]-t_j$  και είναι μικρότερο από το φορτίο $L[k]$ όλων των $k$ μηχανών, όπου $1\leq k \leq m$. 

Επομένων $L[i]-t_j \leq L[k]$ για κάθε $1\leq k \leq m$

Αν αθροίσουμε για όλα τα $k$ θα έχουμε : $m \cdot (L[i]-t_j)\leq \sum_kL[k]$ 

Στη συνέχεια διαιρούμε με το $m$ άρα:   $(L[i]-t_j)\leq \frac{1}{m} \sum_kL[k]=\frac{1}{m} \sum_n t_n$, όπου $n$ συνολικός αριθμός των εργασιών

Γνωρίζουμε όμως από το Λήμμα 2 πως $L^* \geq \frac{1}{m}\sum_n t_n$ 

Επομένως $(L[i]-t_j)\leq \frac{1}{m} \sum_kL[k]=\frac{1}{m} \sum_n t_n \leq L^* \Rightarrow (L[i]-t_j)\leq L^*$

Επομένως για το makespan $L$  το οποίο πετυχαίνουμε με τον άπληστο αλγόριθμο(το οποίο ταυτίζεται με το χρόνο $L[i]$ που χρειάζεται η πιο αργή μηχανή) ισχύει:

![Screenshot_15.png](/img/user/Online%20Algorithms%20and%20Learning/Screenshot_15.png)

---

## Κάτω Φράγμα 


Έχουμε ήδη αποδείξει ότι δεν μπορούμε με τον άπληστο αλγόριθμο μας να τα πάμε χειρότερα από το διπλάσιο του βέλτιστου makespan. Αυτό μας έδειξε ποιο είναι το χειρότερο αποτέλεσμα(όριο) μας σε σχέση με το βέλτιστο. Υπάρχει όμως κάποιο όριο στο πόσο καλά μπορούμε να τα πάμε σε σχέση με το βέλτιστο; Κάποιο κάτω φράγμα όπως λέμε. 

> Θεώρημα: Δεν υπάρχει κανένας ντετερµινιστικός αλγόριθµος µε λόγο ανταγωνισµού µικρότερο από 3/2

Απόδειξη:

- Έστω 2 μηχανές($m=2$)
- Ο αντίπαλος παρουσιάζει 2 εργασίες με χρόνου $t_1=t_2=1$

Εξετάζουμε τις περιπτώσεις:

1. Αν ο αλγόριθμος αναθέσει όλες τις εργασίες σε μια μηχανή, τότε το makespan του θα είναι $L=2$, ενώ το βέλτιστο θα ήταν να χωριστούν στις 2 μηχανές άρα $L^*=1$. Επομένως ο λόγος ανταγωνισμού είναι $r=L/L^*=2$
2. Αν ο αλγόριθμος αναθέσεις τις εργασίες σε διαφορετικές μηχανές, ο αντίπαλος παρουσιάζει μια ακόμα εργασία $t_3=2$. Οπότε τότε το makespan του αλγορίθμου μας θα ήταν $L=3$ ενώ το βέλτιστο θα ήταν να είχε βάλει τις πρώτες εργασίες σε μια μηχανή και την τρίτη στην άλλη, άρα $L^*=2$. Επομένως $r=L/L^*=3/2$

Συνεπώς ο λόγος ανταγωνισµού οποιουδήποτε ντετερµινιστικού αλγορίθµου είναι µεγαλύτερος ή ίσος από 3/2



**Σχόλιο**: Συµπερασµατικά ο προηγούµενος άπληστος αλγόριθµος είναι βέλτιστος για 2 µηχανές, καθώς λειτουργεί σύμφωνα με την περίπτωση 2 που εξετάσαμε στην απόδειξη.

Ενδιαφέρουσα πληροφορία:

> Κάτω Φράγµα (current best) ・[Rudin, 2001] Δεν υπάρχει νετερµινιστικός άµεσος αλγόριθµος που να µπορει να επιτύχει λόγο ανταγωνισµού µικρότερο από 1.88.


