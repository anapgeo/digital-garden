---
{"dg-publish":true,"permalink":"/online-algorithms-and-learning/algorithmoi-simansis-marking-algorithms/","created":"2025-03-25T14:58:23.049+02:00","updated":"2025-03-25T14:59:11.194+02:00"}
---


## Αλγόριθμοι Σήμανσης

Οι αλγόριθμοι σήμανσης για την επίλυση του προβήματος της κρυφής μνήμης είναι μια **κλάση αλγορίθμων** οι οποίοι περιγράφονται από τον παρακάτω ψευδοκώδικα:

![Screenshot_22.png](/img/user/Online%20Algorithms%20and%20Learning/Screenshot_22.png)


Καταλαβαίνουμε πως ο ψευδοκώδικας αυτός περιγράφει μια κλάση αλγορίθμων και όχι κάποιο συγκεκριμένο αλγόριθμο καθώς δεν καθορίζει με πιο τρόπο απομακρύνεται ένα unmarked στοιχείο από την cache. Υπάρχουν πληθώρα επιλογών κριτηρίων για την απομάκρυνση κάποιου unmarked στοιχείου. Τα κριτήρια αυτά μπορεί να είναι τόσο ντετερμινιστικά όσο και τυχαιοκρατικά.

Στη συνέχεια βλέπουμε ένα παράδειγμα εφαρμογής ενός marking αλγόριθμου για μνήμη cache με τρείς θέσεις(k=3), και 5 διαφορετικά πιθανά σύμβολα(N=5). Αρχικά η cache ειναι κενή.
![Screenshot_20.png](/img/user/Online%20Algorithms%20and%20Learning/Screenshot_20.png)
![Screenshot_19.png](/img/user/Online%20Algorithms%20and%20Learning/Screenshot_19.png)

> Σημείωση: Ο αλγόριθμος LRU είναι επι της ουσίας ένας marking αλγόριθμος. Το κριτήριο απομάκρυνσης ενός unmarked στοιχείου είναι το ποιο κελί της cache έχει προσπελαστεί πιο παλιά. Παρακάτω φαίνεται και ένα παράδειγμα λειτουργίας του LRU.
![Screenshot_21.png](/img/user/Online%20Algorithms%20and%20Learning/Screenshot_21.png)


## Ανταγωνιστικότητα Αλγορίθμων Σήμανσης

> **Θεώρημα**: Κάθε ντετερμινιστικός αλγόριθμος σήμανσης είναι k-ανταγωνιστικός 

Απόδειξη 



Ας εξετάσουμε έναν οποιοδήποτε ντετερμινιστικό αλγόριθμο σήμανσης σε μια cache με k θέσεις. Συγκεκριμένα έχουμε μια ακολουθία αιτημάτων $\sigma$. 

Αρχικά θα χρειαστεί να βρούμε ένα άνω όριο για τα cache misses του αλγορίθμου σήμανσης.

Εξετάζουμε μια τυχαία φάση εκτέλεσης του αλγορίθμου στην οποία η cache είναι γεμάτη, έχοντας $k$ διακριτά στοιχεία. Έστω ότι ζητείται μια ακολουθία που περιέχει k διακριτά στοιχεία. Στην περίπτωση αυτή φτάνουμε σε ένα σημείο όπου όλα τα στοιχεία της cache θα είναι marked. Εφόσον όταν κάποιο από τα $k$ στοιχεία όταν ζητηθεί γίνεται marked και παραμένει στην cache για όλη τη διάρκεια της φάσης, αυτό σημαίνει πως τα cache misses που έχουν γίνει στη διάρκεια της φάσης αυτής είναι το πολύ $k$(στην περίπτωση όπου τα $k$ διακριτά στοιχεία που ζητήθηκαν είναι όλα διαφορετικά από αυτά που υπήρχαν αρχικά στην cache). 

H φάση τελειώνει επίσημα όταν ζητηθεί κάποιο διαφορετικό από τα $k$ στοιχεία που προηγήθηκαν και η προηγούμενη ανάλυση επαναλαμβάνεται για την επόμενη φάση.

Επομένως σαν συμπέρασμα έχουμε:

> **Πρόταση 1**: Ο αλγόριθμος σήμανσης επιφέρει το πολύ $k$ αστοχίες ανα φάση, με σύνολο το πολύ $kr$ αστοχίες σε $r$ φάσεις

Στη συνέχεια θα προσπαθήσουμε να βρούμε ένα κάτω όριο για τα cache misses του βέλτιστου αλγορίθμου. 

Ο βέλτιστος αλγόριθμος, αναγκαστικά θα κάνει τουλάχιστον 1 λάθος στο τέλος κάθε φάσης καθώς ακόμα και αν τα $k$ στοιχεία που έχει στην cache στην αρχή κάθε φάσης είναι ίδια με τα στοιχεία που θα ζητηθούν στα αιτήματα της φάσης αυτής, όταν η φάση τελειώσει θα ζητηθεί ένα στοιχείο που ανήκει στο σύνολο των $k+1$ διακριτών στοιχείων. Αναγκαστικά τότε θα πρέπει να υπάρξει μια αστοχία του αλγορίθμου. 

Επομένως έχουμε το εξής συμπέρασμα:

> **Πρόταση 2**: Ο βέλτιστος αλγόριθμος θα επιφέρει τουλάχιστον $r-1$ αστοχίες, όπου $r$ ο αριθμός των φάσεων. Άρα για τα συνολικά σφάλματα $f(\sigma)$ του βέλτιστου αλγορίθμου θα ισχύει $f(σ)\geq r-1$

Αξιοποιώντας τις παραπάνω προτάσεις καταλήγουμε στο εξής:

> **Συμπέρασμα**: Για κάθε αλγόριθμο σήμανσης ο αριθμός των αστοχιών που επιφέρει μια ακολουθία $\sigma$ είναι το πολύ $k\cdot f(\sigma) + k$ 

Αυτό γιατί : 
$$
kr=k(r-1)+k\leq k \cdot f(\sigma) + k
$$

> Σημείωση: Ιδιαίτερο ενδιαφέρον έχει ο LRU (ο οποίος είναι ντετερμινιστικός αλγόριθμος σήμανσης όπως αναφέραμε προηγουμένως), για τον οποίο το καλύτερο δυνατό όριο είναι το $k\cdot f(\sigma) + k$, καθώς στο πλαίσιο του competitive analysis όπου κάποιος αντίπαλος επιλέγει την ακολουθία των αιτημάτων, μπορεί να επιλέξει να γίνεται συνεχώς αίτημα συγκεκριμένων $k+1$ στοιχείων με κυκλικό(περιοδικό τρόπο). Στην περίπτωση αυτή ο αλγόριθμος LRU θα επιφέρει $k$ αστοχίες σε κάθε φάση. 
## Τυχαιοποιημένος Αλγόριθμος Σήμανσης

Μπορούμε να πετύχουμε καλύτερη ανταγωνιστικότητα σε σύγκριση με τους ντετερμινιστικούς αλγορίθμους σήμανσης; Όπως θα γίνει φανερό στη συνέχεια, αυτό είναι δυνατό με την χρήση τυχαιοποιημένων αλγορίθμων σήμανσης. Ο ψευδοκώδικας ενός τέτοιου τυχαιοποιημένου αλγορίθμου φαίνεται παρακάτω(η μόνη διαφορά με τον ντετερμινιστικό είναι η τυχαία επιλογή απομάκρυνσης του unmarked στοιχείου):


![Τυχαιοποιημένος Αλγόριθμος](/img/user/Online Algorithms and Learning/Screenshot_2024-06-14_18-42-34.png)

Μπορούμε να αποδείξουμε πως ο τυχαιοποιημένος αλγόριθμος που αναφέραμε είναι $Ο(log k)$-ανταγωνιστικός

### Ανάλυση Τυχαιοποιημένου Αλγόριθμου

> **Θεώρημα**: Ο τυχαιοποιημένος αλγόριθμος σήμανσης είναι $O(log k)$-ανταγωνιστικός.

Απόδειξη

Η ανάλυση μας σε αυτή την απόδειξη βασίζεται στην ανάλυση που είχαμε κάνει και για τους ντετερμινιστικούς αλγορίθμους αλλά με κάποιες τροποποιήσεις.

Συγκεκριμένα, η ανάλυση μας θα πρέπει να γίνει λίγο πιο εκλεπτυσμένη θα λέγαμε. Αυτό γιατί ναι μεν ο τυχαιοποιημένος αλγόριθμος θα μπορούσε να κάνει $kr$ αστοχίες αλλά αυτό είναι αρκετά πιο απίθανο να συμβεί σε σύγκριση με τον ντετερμινιστικό αλγόριθμο. Μια απλή περίπτωση που αυτό θα μπορούσε να συμβεί είναι τα $k$ στοιχεία που θα ζητηθούν σε μια φάση του αλγορίθμου να είναι όλα διαφορετικά από αυτά που ζητήθηκαν στην ακριβώς προηγούμενη φάση. Επί της ουσίας όμως μια τέτοια περίπτωση θα οδηγούσε σε μεγάλο αριθμό αστοχιών και το βέλτιστο αλγόριθμο. Έτσι δεν θα ίσχυε το κάτω όριο του $r-1$.


Θα διαχωρίσουμε τα unmarked στοιχεία μιας φάσης $j$, σε: 
- φρέσκα στοιχεία: δεν έχουν ζητηθεί στην $j-1$ φάση 
- παλιά στοιχεία: έχουν ζητηθεί στην $j-1$ φάση

Σε κάθε φάση $j$ γίνονται αιτήματα για k unmarked στοιχεία. Θα συμβολίζουμε τα φρέσκα στοιχεία της φάσης $j$ ως $c_j$. Τα παλιά στοιχεία είναι $k-c_j$.

> **Πρόταση 1**: Για το συνολικό αριθμό αστοχιών(cache misses) $f(\sigma)$ του βέλτιστου αλγορίθμου θα ισχύει: $f(σ)\geq \frac{1}{2}\sum_{j=1}^{r}c_j$, όπου $r$ ο συνολικός αριθμός των φάσεων

Απόδειξη

Έστω $f_j(\sigma)$ οι αστοχίες που γίνονται από το βέλτιστο αλγόριθμο σε μια φάση $j$, όπου έγιναν αιτήματα για $k$ διακριτά στοιχεία. Στην φάση $j+1$ θα γίνουν αιτήματα για επιπλέον $c_{j+1}$ διακριτά στοιχεία. Άρα από τη μετάβαση από τη φάση  $j$ στη φάση $j+1$, θα γίνουν τουλάχιστον $c_{j+1}$ αστοχίες(τα στοιχεία αυτά δεν υπάρχουν στην cache στην αρχή της φάση $j+1$, επομένως αναγκαστικά θα οδηγήσουν σε αστοχίες). Επομένως ισχύει $f_j(\sigma) + f_{j+1}(\sigma) \geq c_{j+1}$. Αν κάνουμε άθροιση για όλες τις μεταβάσεις φάσεων έχουμε: 

$$
\sum_{j=0}^{r-1}(f_j(\sigma) + f_{j+1}(\sigma)) \geq \sum_{j=0}^{r-1} c_{j+1}
$$

Το αριστερό σκέλος είναι ίσο με $2\sum_{j=1}^{r}f_j(\sigma)=2f(\sigma)$, ενώ το δεξί μέλος με $\sum_{j=1}^{r} c_{j}$



> **Πρόταση 2**:  Για κάθε ακολουθία αιτημάτων $\sigma$, ισχύει $E[M_{\sigma}] \leq H(k)\sum_{j=1}^{r}c_j$, όπου $M_σ$ τυχαία μεταβλητή που ισούται με τον αριθμό των αστοχιών του τυχαιοποιημένου αλγορίθμου για την ακολουθία $\sigma$

Απόδειξη

Είναι προφανές πως ο τυχαιοποιημένος αλγόριθμος θα έχει τουλάχιστον $c_j$ αστοχίες στη διάρκεια μιας φάσης $j$. Τα στοιχεία $c_j$ δεν υπάρχουν στην cache στην έναρξη της φάσης $j$ οπότε το αίτημα τους σίγουρα θα οδηγήσει σε αστοχία.

Πέραν των φρέσκων στοιχείων $c_j$ που ζητούνται στη φάση j υπάρχουν και άλλα $k-c_j$ unmarked παλιά στοιχεία τα οποία είχαν ζητηθεί και στην προηγούμενη φάση και ζητούνται και στη $j$. Ο υπολογισμός ενός ορίου λαθών στα παλιά στοιχεία είναι μια πιο λεπτή υπόθεση. Σκεφτείτε πως κατα την διάρκεια της εκτέλεσης του αλγορίθμου μπορεί να απομακρυνθεί κάποιο unmarked παλιό στοιχείο το οποίο να ζητηθεί στη συνέχεια(ένας βέλτιστος offline αλγόριθμος μπορεί να αποφύγει πολλά από αυτά τα λάθη καθώς γνωρίζει τα στοιχεία που θα ζητηθούν) 

Πάμε να εξετάσουμε σε μια τυχαία στιγμή της εκτέλεσης του αλγορίθμου σε μια φάση j, όπου εξυπηρετείτε το i-οστό αίτημα από ενός παλιού στοιχείου, έστω s το στοιχείο αυτό(προσοχή αναφερόμαστε στην i-οστή φορά που ζητείται ένα παλιό στοιχείο, και όχι γενικά στο i-οστό αίτημα).  Τη στιγμή εκείνη η κατάσταση της cache έχει ως εξής:
- Υπάρχουν $c \leq c_j$ φρέσκα στοιχεία 
- Έχουν γίνει marked $i-1$ παλιά στοιχεία(ζητήθηκαν στη φάση $j$ πριν το s)
- Υπάρχουν $k-c-(i-1)$ παλιά στοιχεία που δεν ζητήθηκαν ακόμα

Επομένως, έχουν απομακρυνθεί $c$ παλιά στοιχεία με ίση πιθανότητα(αντικαταστήθηκαν από τα φρέσκα στοιχεία). Άρα η πιθανότητα το s να βρίσκεται ανάμεσα στα στοιχεία που απομακρύνθηκαν είναι $\frac{c}{k-(i-1)}\leq \frac{c_j}{k-(i-1)}$

Ορίζουμε $X_j$ την τυχαία μεταβλητή που ισούται με το πλήθος των αστοχιών στη φάση $j$. Τότε:

$$
Ε[Χ_j]\leq c_j + \sum_{i=1}^{k-c_j} \frac{c_j}{k-(i-1)} \leq c_j(1 + \sum_{l=c_j+1}^{k} \frac{1}{l})=c_j(1+H_k -H_{c_j})\leq c_jH_k
$$
(Επεξήγηση: Γνωρίζουμε πως η πιθανότητα λάθους για ένα παλίο στοιχείο που εισέρχεται είναι το πολύ $\frac{c_j}{k-(i-1)}$, επομένως η πιθανότητα να γίνει λάθος συνολικά για τα $k-c_j$ παλιά στοιχεία που θα ζητηθούν είναι το πολύ $\sum_{i=1}^{k-c_j} \frac{c_j}{k-(i-1)}$.  Αθροίζουμε σε αυτό το άνω όριο στη συνέχεια τα λάθη που προέρχονται από τα νέα στοιχεία)

Αθροίζοντας τα $Ε[Χ_j]$ για όλες τις φάσεις έχουμε για την $M_\sigma$:

$$
Ε[M_\sigma]=\sum_{j=1}^{r}Ε[Χ_j]\leq H_k\sum_{j=1}^{r}c_j
$$

Συνδυάζοντας τώρα τις προτάσεις 1,2 έχουμε ότι για τον αναμενόμενο αριθμό αστοχιών $E[M_\sigma]$ του τυχαιοκρατικού αλγόριθμου ισχύει:

$Ε[Μ_σ]\leq H(k)\cdot 2f(\sigma) = Ο(log k)\cdot f(\sigma)$

---
