---
{"dg-publish":true,"permalink":"/online-algorithms-and-learning/beltisti-kryfi-mnimi-cache/","created":"2025-03-25T14:58:23.184+02:00","updated":"2025-03-28T12:31:40.361+02:00"}
---

Έστω μια κρυφή Μνήμη ή μνήμη cache η οποία έχει χωρητικότητα k στοιχείων. Η μνήμη αυτή δέχεται m αιτήματα στοιχείων $d_1,d_2,...,d_m$. H μνήμη επιτυγχάνει(**cache hit**) όταν το στοιχείο $d_i$ που ζητήθηκε σε ένα από τα αιτήματα υπήρχε στη μνήμη όταν ζητήθηκε. Αντίθετα αν δεν υπήρχε θα είχαμε αστοχία(**cache miss**), και τότε θα πρέπει να απομακρύνουμε κάποιο στοιχείο από τη μνήμη για να προσθέσουμε το αιτούμενο στοιχείο.

![Screenshot_17.png|400](/img/user/Online%20Algorithms%20and%20Learning/Screenshot_17.png)


Η μνήμες cache έχουν πληθώρα εφαρμογών σε CPUs, RAMs ή και σκληρούς δίσκους


## Το πρόβλημα

Όπως είπαμε και προηγουμένως θα πρέπει εάν υπάρξει cache miss να απομακρυνθεί κάποιο στοιχείο από την μνήμη ώστε να προστεθεί το αιτούμενο στοιχείο. Ποιος είναι όμως ο βέλτιστος αλγόριθμος, σύμφωνα με τον οποίο θα απομακρύνουμε στοιχεία στην περίπτωση των cache miss, ο οποίος ελαχιστοποιεί το αριθμό των cache miss;

Το πρόβλημα που έχουμε να αντιμετωπίσουμε είναι ένα **online(άμεσο) πρόβλημα**, καθώς θα μας έρχεται ένα νέο αίτημα και θα πρέπει να αποφασίζουμε άμεσα το ποιο στοιχείο θα απομακρύνουμε χωρίς να γνωρίζουμε την είσοδο που πρόκειται να έρθει στη συνέχεια. Φυσικά υπάρχει και η **offline έκδοση του προβλήματος** όπου γνωρίζουμε όλα τα αιτήματα και βρίσκουμε το βέλτιστο που θα μπορούσαμε να κάνουμε ώστε να έχουμε τα λιγότερα cache miss. Με αυτό το βέλτιστο offline αλγόριθμο θα συγκρίνουμε τον online αλγόριθμο που θα προτείνουμε.


Για παράδειγμα στην εικόνα που δείξαμε παραπάνω έχουμε μια μνήμη 2 στοιχείων(k=2). Βλέπουμε με offline τρόπο ότι το βέλτιστο που θα μπορούσαμε να πετύχουμε είναι 2 cache miss.


## Άπληστοι Αλγόριθμοι

Κάποιοι άπληστοι αλγόριθμοι που μπορούν να χρησιμοποιηθούν για τη λύση του online προβλήματος που αναφέραμε είναι:

1. **FIFO**(First-In-First-Out) -> Απομάκρυνε το στοιχείο της cache που εντάχθηκε σε αυτήν πιο παλιά
2. **LIFO**(Last-In-First-Out) -> Απομάκρυνε το στοιχείο που μπήκε πιο πρόσφατα στην cache
3. **LRU**(Least Recently Used) -> Απομάκρυνε το στοιχείο του οποίου η πιο πρόσφατη πρόσβαση είναι πιο παλιά(δηλαδή έχει να ζητηθεί τελευταία φορά πιο παλιά σε σχέση με τα άλλα στοιχεία της cache)
4. **LFU**(Least Recently Used) -> Αποµάκρυνε το στοιχείο µε την µικρότερη συχνότητα

>Σημείωση: Για να καταλάβουμε λίγο καλύτερα το πως λειτουργούν οι παραπάνω αλγόριθμοι, όταν αναφέρουμε στοιχεία εννούμε κελιά της μνήμης και όχι το περιεχόμενο. Δηλαδή όταν εξετάζω στην περίπτωση της LRU ποιο στοιχείο είχε πιο πρόσφατη πρόσβαση κοιτάζω τα κελιά της μνήμης μου. Δηλ στην περίπτωση των 2 κελιών όπως στην εικόνα που είχαμε δείξει εξετάζω το πότε έγινε η τελευταία πρόσβαση σε κάθε κελί και σε αυτό που είναι πιο παλιά η τελευταία πρόσβαση στην περίπτωση του cache miss αντικαθιστώ το περιεχόμενο του. Αντίστοιχα στη LFU κρατάω έναν counter για κάθε κελί, και μετράω το πόσες φορές έχει γίνει πρόσβαση σε κάθε κελί. Όταν υπάρξει cache miss τότε αντικαθιστώ το στοιχείο που βρίσκεται στο κελί με τις λιγότερες προσβάσεις. Συνποτικά, δεν κρατάω πρακτικά πόσες φορές είδα το στοιχείο a γενικά, αλλά το κελί που βρίσκεται. Άρα αν κάποια στιγμή το a μείνει εκτός cache και ξαναμπεί ο counter αρχικοποείται και πάλι. 


## Βέλτιστος Offline Αλγόριθμος


Σύμφωνα με θεώρημα ο βέλτιστος αλγόριθμος για την επίλυση του offline προβλήματος είναι ο **FF**(Farthest-in-Future). Σύμφωνα με τον αλγόριθμο αυτόν όταν διαπιστώνουμε cache miss απομακρύνουμε το στοιχείο της cache το οποίο καθυστερεί περισσότερο να ζητηθεί στο μέλλον(στο offline πρόβλημα θυμηθείτε πως γνωρίζουμε όλα τα αιτήματα που θα γίνουν)

Η απόδειξη του παραπάνω θεωρήματος είναι αρκετά πολύπλοκη και δεν θα την αναφέρουμε, αλλά μπορούμε να καταλάβουμε και διαισθητικά το λόγο που αυτή η λύση είναι βέλτιστη.

## Ανταγωνιστικότητα(Competitiveness)

Ο LRU αλγόριθμος είναι k-ανταγωνιστικό(k-competitive) του FF αλγορίθμου. Αυτο σημαίνει πως για κάθε ακολουθία αιτημάτων $σ$, ισχύει για τα cache misses $LRU(σ)$ ότι: $LRU(\sigma)\leq kFF(\sigma) + k$

Μπορούμε εύκολα να καταλάβουμε πως ο LIFO για παράδειγμα δεν είναι ανταγωνιστικός καθώς σκεφτείτε πως στο πλαίσιο του competitive analysis όπου έχουμε έναν αντίπαλο ο οποίος επιλέγει την ακολουθία αιτημάτων $σ$, μπορεί ο αντίπαλος να κατασκευάσει μια τέτοια ακολουθία στην οποία θα έχουμε συνεχώς cache miss του LIFO.

Στη συνέχεια θα δούμε και αλγορίθμους στο [[Online Algorithms and Learning/Αλγόριθμοι Σήμανσης(Marking Algorithms)\|Αλγόριθμοι Σήμανσης(Marking Algorithms)]] οι οποίοι τα πάνε καλύτερα από τον LRU. Συγκεκριμένα o πιθανοτικός αλγόριθμος σήμανσης είναι $Ο(logk)$-ανταγωνιστικός του FF. 